/*
 *  swifi.c
 *  Created on: Feb 11, 2012
 *      Author: Takeshi Yoshimura
 *  SWIFI is originally created by Ng and Swift
 *  This is the porting version for the latest x86 Linux kernel
 */

#include <linux/kernel.h>
#include <linux/kallsyms.h>
#include <linux/syscalls.h>
#include <asm/pgalloc.h>
#include <linux/sched.h>
#include <asm/uaccess.h>
#include <asm/sections.h>
#include <linux/slab.h>
#include <asm/types.h>
#include "dis-asm.h"
#include "swifi.h"

#if defined(CONFIG_X86)
static const u8 NOP = 0x90;
#endif
#if defined(CONFIG_X86_32)
static const long RND_STUFF = 0x7fffffff;
#elif defined(CONFIG_X86_64)
static const long RND_STUFF = 0x7fffffffffffffff;
#endif

static void show_u128(u128 * str) 
{
    char str2[128];
    u8 * p;
    memset(str2, 0, 128);
    p = (u8 *)str;
    sprintf(str2, "%x", *p);
    for (p = (u8 *)str + 1; p < (u8 *)str + sizeof(u128); p++)
        sprintf(str2, "%s %x", str2, *p);
    printk(KERN_INFO "0x%lx: %s\n", str, str2);
}

static unsigned long tstart = (unsigned long)_stext;
static unsigned long tend   = (unsigned long)_etext;

/* functions for getting random & deterministic integers */

static unsigned long seed = 1;

static void srand(unsigned long random_seed) 
{
	seed = random_seed;
}

static unsigned long rand(void) 
{
	long x, hi, lo, t;
	
	x = seed;
	hi = x / 127773;
	lo = x % 127773;
	t = 16807 * lo - 2836 * hi;
	if (t <= 0)
		t += RND_STUFF;
	seed = t;
	return t;
}

static unsigned long rand_range(unsigned long start, unsigned long end) 
{
	unsigned long range = end - start - sizeof(unsigned long);
	
	if(end <= start + sizeof(u128))
		return 0;
	return rand() % range + start;
}

/* functions to change instructions as a fault */

static void force_to_write(u128 * target, u128 * inject)
{
	pte_t * ppt, pt;
    unsigned int level;

    if(pte_write(*lookup_address((unsigned long)target, &level)) == 0) {
		ppt = lookup_address((unsigned long)target, &level);
		pt = pte_mkwrite(*ppt);
		set_pte(ppt, pt);
		*target = *inject;
		ppt = lookup_address((unsigned long)target, &level);
		pt = pte_wrprotect(*ppt);
		set_pte(ppt, pt);
	}else {
	    *target = *inject;
	}
}

static u128 do_nothing(unsigned long addr, size_t byte)
{
   return *(u128 *)addr; 
}

static u128 test_flip_random_bit(unsigned long addr, size_t byte) 
{
	u128 target = *(u128 *)addr;
	u64 flip_bit;
	u64 * flip_target;

	flip_bit = (u64)(rand() % (byte * 8));
	if (flip_bit < sizeof(u64) * 8)
		flip_target = &target.low;
	else
		flip_target = &target.high;
	flip_bit = 1 << (flip_bit % (sizeof(u64) * 8));
	*flip_target = *flip_target ^ flip_bit;
    return target;
}

static u128 flip_random_bit(unsigned long addr, size_t byte) 
{
    u128 inject = test_flip_random_bit(addr, byte);
	force_to_write((u128 *)addr, &inject);
    return *(u128 *)addr;
}

static u128 test_fill_nop(unsigned long addr, size_t byte) 
{
	u128 target = *(u128 *)addr;
	u8 * p;
    if (byte > sizeof(u128))
        byte = sizeof(u128);
	for(p = (u8 *)&target; p != (u8 *)&target + byte; p++)
		*p = NOP;
    return target;
}

static u128 fill_nop(unsigned long addr, size_t byte) 
{
	u128 inject = test_fill_nop(addr, byte);
    force_to_write((u128 *)addr, &inject);
    return *(u128 *)addr;
}

/* original dst/src: flip bits in mod/rm, sib, disp or imm fields
 *
 * new dst/src fault checks if sizeof instruction remains 
 * not to corrupt later intructions.
 */

static int inst_not_currupted(unsigned long addr, unsigned long target)
{
    u8 * op1, * op2;
    u8 * mod1, * mod2;
    size_t byte, byte2;
    
    byte  = do_disasm(addr, NULL, 0);
    op1   = get_opcode_addr();
    mod1  = get_modrm_addr();

    byte2 = do_disasm(target, NULL, 0);
    op2   = get_opcode_addr();
    mod2  = get_modrm_addr();

    if (*op1 != *op2 || byte != byte2)
        return 0;
    /* avoid opcode change by changing modrm extension (c.f. AMD manual pp. 349)*/
    if ((0x80 <= *op1 && *op1 <= 0x83) ||
        (*op1 == 0x8f) ||
        (0xc0 <= *op1 && *op1 <= 0xc1) ||
        (0xc6 <= *op1 && *op1 <= 0xc7) ||
        (0xd0 <= *op1 && *op1 <= 0xd3) ||
        (0xf6 <= *op1 && *op1 <= 0xf7) ||
        (0xfe <= *op1 && *op1 <= 0xff)) {
        if (8 <= (*mod1 ^ *mod2) && (*mod1 ^ *mod2) <= 32) //avoid to change reg
           return 0;
    }
    return 1;
}

static u128 test_flip_dstsrc(unsigned long addr, size_t byte) 
{
	u128 target = *(u128 *)addr;
    u128 tmp = target; 
    unsigned long start;
    int i;

    printk(KERN_INFO "dstsrc[-1]\n");show_u128(&target);
    for(i = 0; i < 100; i++) {
        do_disasm((unsigned long)&target, NULL, 0);
        start = (unsigned long)get_modrm_addr();
        if (!start || start < (unsigned long)&target || start >= (unsigned long)&target + byte)
            return target;
        flip_random_bit(start, byte - (start - (unsigned long)&target));
        printk(KERN_INFO "dstsrc[%d]\n", i);show_u128(&target);
        if (inst_not_currupted(addr, (unsigned long)&target))
           break;
        target = tmp;
    }
	return target;
}

static u128 flip_dstsrc(unsigned long addr, size_t byte) 
{
	u128 inject = test_flip_dstsrc(addr, byte);
    force_to_write((u128 *)addr, &inject);
	return *(u128 *)addr;
}

/* original ptr: if instruction has regmodrm byte,
 * and mod field has address ([eyy]dispxx),
 * eyy!=ebp flip 1 bit in lower byte (0x0f) or any bit in following bytes (sib, imm or disp).
 *
 * new ptr fault excludes nop with regmodrm
 */

static u128 test_flip_ptr(unsigned long addr, size_t byte) 
{
	u128 target = *(u128 *)addr;
    u128 tmp = target;
	u8 * mod1, * mod2;
    int i;
    printk(KERN_INFO "ptr.byte = %d\n", byte);
    printk(KERN_INFO "ptr[-1]\n");show_u128(&target);
    for (i = 0; i < 100; i++) {
        target = test_flip_dstsrc((unsigned long)&target, byte);
        do_disasm((unsigned long)&target, NULL, 0);
        mod1 = get_modrm_addr();
        do_disasm((unsigned long)&tmp, NULL, 0);
        mod2 = get_modrm_addr();
        printk(KERN_INFO "ptr[%d]\n", i);show_u128(&target);
        if (0x00 < (*mod1 ^ *mod2) && (*mod1 ^ *mod2) <= 0x0f)
            break;
        if ((target.low ^ tmp.low) || (target.high ^ tmp.high))
            break;
        target = tmp;
    }
	return target;
}

static u128 flip_ptr(unsigned long addr, size_t byte) 
{
	u128 inject = test_flip_ptr(addr, byte);
    force_to_write((u128 *)addr, &inject);
	return *(u128 *)addr;
}

/* original inverse fault is loop fault,but original loop fault does almost only inverse jmp instructions.
 * loop fault handles rep instruction, but new inverse fault doesn't handle.
 * 
 */

static u128 test_inverse_branch(unsigned long addr, size_t byte) 
{
	u128 target = *(u128 *)addr;
    u8 * opcode;
    do_disasm((unsigned long)&target, NULL, 0);
    opcode = get_opcode_addr();
    if (!opcode || opcode < (u8 *)&target || opcode >= (u8 *)&target + byte)
        return target;
    if (*opcode == 0x0f)
        opcode++;
    if (*opcode % 2 == 0)
        *opcode += 1;
    else
        *opcode -= 1;
	return target;
}

static u128 inverse_branch(unsigned long addr, size_t byte) 
{
    u128 inject = test_inverse_branch(addr, byte);
    force_to_write((u128 *)addr, &inject);
	return *(u128 *)addr;
}

static u128 test_offbyone(unsigned long addr, size_t byte)
{
    u128 target = *(u128 *)addr;
    u8 * opcode;
    do_disasm((unsigned long)&target, NULL, 0);
    opcode = get_opcode_addr();
    if (!opcode || opcode < (u8 *)&target || opcode >= (u8 *)&target + byte)
        return target;
    
    if (*opcode == 0x72) //jb
        *opcode = 0x76;
    else if (*opcode == 0x73) //jae
        *opcode = 0x77;
    else if (*opcode == 0x76) //jbe
        *opcode = 0x72;
    else if (*opcode == 0x77) //ja
        *opcode = 0x73;
    else if (*opcode == 0x7c) //jl
        *opcode = 0x7e;
    else if (*opcode == 0x7d) //jge
        *opcode = 0x7f;
    else if (*opcode == 0x7e) //jle
        *opcode = 0x7c;
    else if (*opcode == 0x7f) //jg
        *opcode = 0x7d;

    if (*opcode == 0x0f)
        opcode++;
   
    if (*opcode == 0x82) //jb
        *opcode = 0x86;
    else if (*opcode == 0x83) //jae
        *opcode = 0x87;
    else if (*opcode == 0x86) //jbe
        *opcode = 0x82;
    else if (*opcode == 0x87) //ja
        *opcode = 0x83;
    else if (*opcode == 0x8c) //jl
        *opcode = 0x8e;
    else if (*opcode == 0x8d) //jge
        *opcode = 0x8f;
    else if (*opcode == 0x8e) //jle
        *opcode = 0x8c;
    else if (*opcode == 0x8f) //jg
        *opcode = 0x8d;

	return target;
}

static u128 offbyone(unsigned long addr, size_t byte)
{
    u128 inject = test_offbyone(addr, byte);
    force_to_write((u128 *)addr, &inject);
	return *(u128 *)addr;
}
/* functions to target address to inject a fault
 */

static unsigned long get_null(void)
{
    return 0;
}

static unsigned long get_random_text_addr(void)
{
	unsigned long target;
	int i;
	
	target = rand_range(tstart,tend) - 2 * 10;
	for(i = 0; i < 10; i++)
		target += do_disasm(target, NULL, 1);
	return target;
}

static unsigned long get_random_stack_addr(void)
{
	struct task_struct * task = NULL;
	int i = 0;

	for_each_process(task) {
		i++;
	}

	i = rand() % i;

	for_each_process(task) {
		if (--i == 0)
			break;
	}

	if (task == NULL)
		return 0;
	
	return rand_range((unsigned long)task->thread.sp,
            (unsigned long)task->stack + THREAD_SIZE);
}

static unsigned long get_random_heap_addr(void) 
{
	return 0;
}

static unsigned long get_random_data_addr(void) 
{
	return rand_range((unsigned long)_sdata, (unsigned long)_edata);
}

static unsigned long get_random_bss_addr(void) 
{
	return rand_range((unsigned long)__bss_start, (unsigned long)__bss_stop);
}

/* origianl init fault: from SOF, look for movl $X, -Y(%ebp),
 * (C645Fxxx or C745Fxxx) and replace with nop.
 *
 * new init fault doesn't look for them from SOF but from a random instruction.
 * REX == 40 or 42 or 44 or 46, opcode == C6 or C7, modRM == 45 or 85, and disp < 0
 * if not found over 1000 instructions, then return NULL
 */
static int is_init_instr(void)
{
	u8 * rex    = get_rex_addr();
	u8 * opcode = get_opcode_addr();
	u8 * modrm  = get_modrm_addr();
	u8 dispsize = get_disp_size();

	if (!opcode || !modrm)
		return 0;

	if (((rex && (*rex | 0x06 == 0x46)) || !rex) &&
		(*opcode == 0xc6 || *opcode == 0xc7) &&
		(*modrm == 0x45 || *modrm == 0x85)) {
		if (dispsize == 8) {
			s8 * disp = (s8 *)get_disp_addr();
			if (*disp < 0)
				return 1;
			return 0;
		} else if (dispsize == 32) {
			s32 * disp = (s32 *)get_disp_addr();
			if (*disp < 0)
				return 1;
			return 0;
		}
	}
	return 0;
}

static unsigned long get_init_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	
	target = get_random_text_addr();

	while(1) {
		next = do_disasm(target, NULL, 1);
		if (i++ > 10000)
			return 0;
		if(is_init_instr())
			break;
		target += next;
	}
	return target;
}

/* original ptr: if instruction has regmodrm byte (i_has_modrm),
 * and mod field has address ([eyy]dispxx),
 * eyy!=ebp flip 1 bit in lower byte (0x0f) or any bit in following bytes (sib, imm or disp).
 *
 * new ptr fault excludes nop with regmodrm
 */

static int is_ptr_instr(u8 * str)
{
	if (strstr(str, "rbp") || strstr(str, "ebp") || strstr(str, "nop"))
		return 0;
	if (get_sib_addr() || get_disp_addr())
		return 1;
	return 0;
}

static unsigned long get_ptr_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	u8 * str = kzalloc(256, GFP_KERNEL);
	
    if (!str)
        return 0;

	target = get_random_text_addr();

	while(1) {
        memset(str, 0, 255);
		next = do_disasm(target, str, 1);
		if (i++ > 10000) {
            kfree(str);
			return 0;
        }
		if(is_ptr_instr(str))
			break;
		target += next;
	}
	kfree(str);
	return target;
}

/* original interface: look for movl XX(ebp), reg or movb XX(ebp), reg, where XX is positive.
 * replace instr with nop. movl=0x8a, movb=0x8b, mod=01XXX101 (disp8[ebp]), disp>0
 *
 * in new version, mod=10XXX101 is also targeted
 */

static int is_interface_instr(void)
{
	u8 * rex    = get_rex_addr();
	u8 * opcode = get_opcode_addr();
	u8 * modrm  = get_modrm_addr();
	u8 dispsize = get_disp_size();

	if (!opcode || !modrm)
		return 0;

	if ((!rex || ((*rex | 0x06) == 0x46)) &&
		(*opcode == 0x8a || *opcode == 0x8b) &&
		((*modrm & ~0x38) == 0x85 || (*modrm & ~0x38) == 0x45)) {
		if (dispsize == 8) {
			s8 * disp = (s8 *)get_disp_addr();
			if (disp && *disp > 0)
				return 1;
			return 0;
		} else if (dispsize == 32) {
			s32 * disp = (s32 *)get_disp_addr();
			if (disp && *disp > 0)
				return 1;
			return 0;
		}
	}
	return 0;
}

static unsigned long get_interface_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	
	target = get_random_text_addr();

	while(1) {
		next = do_disasm(target, NULL, 1);
		if (i++ > 10000)
			return 0;
		if(is_interface_instr())
			break;
		target += next;
	}
	return target;
}

/* original dst/src: flip bits in mod/rm, sib, disp or imm fields */

static int is_dstsrc_instr(void)
{
	u8 * opcode = get_opcode_addr();
	u8 * modrm  = get_modrm_addr();

	if (!opcode || !modrm || *opcode == 0x0f) // don't handle two bytes instruction 
		return 0;
	return 1;
}

static unsigned long get_dstsrc_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	
	target = get_random_text_addr();

	while(1) {
		next = do_disasm(target, NULL, 1);
		if (i++ > 10000)
			return 0;
		if(is_dstsrc_instr())
			break;
		target += next;
	}
	return target;
}

/* original branch: search forward utnil we hit a Jxx or rep (F3 or F2).
 * replace instr with nop.
 * this function is also used for inverse falut.
 */

static int is_branch_instr(void)
{
	u8 * opcode = get_opcode_addr();

	if (!opcode)
		return 0;
	else if ((0x70 <= *opcode && *opcode <= 0x7f) ||
		(*opcode == 0x0f && 0x80 <= *(opcode + 1) && *(opcode + 1) <= 0x8F))
		return 1;
	return 0;
}

static unsigned long get_branch_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	
	target = get_random_text_addr();

	while(1) {
		next = do_disasm(target, NULL, 1);
		if (i++ > 10000)
			return 0;
		if(is_branch_instr())
			break;
		target += next;
	}
	return target;
}

static int is_offbyone_instr(void)
{
    u8 *opcode = get_opcode_addr();
    u8 *opcode2 = opcode + 1;

    if (!opcode)
        return 0;
    if (*opcode == 0x72 || //jb
        *opcode == 0x73 || //jae
        *opcode == 0x76 || //jbe
        *opcode == 0x77 || //ja
        *opcode == 0x7c || //jl
        *opcode == 0x7d || //jge
        *opcode == 0x7e || //jle
        *opcode == 0x7f)   //jg
        return 1;
    if (*opcode == 0x0f &&
        (*opcode2 == 0x82 || //jb
         *opcode2 == 0x83 || //jae
         *opcode2 == 0x86 || //jbe
         *opcode2 == 0x87 || //ja
         *opcode2 == 0x8c || //jl
         *opcode2 == 0x8d || //jge
         *opcode2 == 0x8e || //jle
         *opcode2 == 0x8f))  //jg
       return 1; 
    return 0;
}

static unsigned long get_offbyone_instr(void)
{
	unsigned long target;
	unsigned long next;
	int i = 0;
	
	target = get_random_text_addr();

	while(1) {
		next = do_disasm(target, NULL, 1);
		if (i++ > 10000)
			return 0;
		if(is_offbyone_instr())
			break;
		target += next;
	}
	return target;
}
 
/* 4 functions for reporting fault injection results
 *
 * result_stack: used when injected faults to kernel stacks 
 * result_text: used when injected faults to kernel text
 * result_other: used when injected faults to other kerenel segments
 * result_nothing: used when cmd is unkonwn
 */

static void result_stack(struct swifi_result * res)
{
    snprintf(res->str, 99, "pid:%d(%s)",
			((struct thread_info *)(res->target & (0L - THREAD_SIZE)))->task->pid,
			((struct thread_info *)(res->target & (0L - THREAD_SIZE)))->task->comm);
}

static void result_other(struct swifi_result * res)
{
    snprintf(res->str, 99, "address:%lx", res->target);
}

static void result_text(struct swifi_result * res)
{
    unsigned long offset;
    char * namebuf;
    
    namebuf = kzalloc(256, GFP_KERNEL);
    if (!namebuf)
        return;
	kallsyms_lookup(res->target, NULL, &offset, NULL, namebuf);
    snprintf(res->str, 99, "symbol:%s+0x%lx", namebuf, offset);
    do_disasm((bfd_vma)&res->old_content, res->old_instr, 0);
    do_disasm((bfd_vma)&res->new_content, res->new_instr, 0);
    kfree(namebuf);
}

static void result_nothing(struct swifi_result * res)
{
    snprintf(res->str, 99, "nothing to do");
}

/**/

static int is_text_fault(int cmd)
{
    switch(cmd) {
        case SWIFI_TEXT:
        case SWIFI_BRANCH:
        case SWIFI_INVERSE:
        case SWIFI_PTR:
        case SWIFI_DSTSRC:
        case SWIFI_INTERFACE:
        case SWIFI_INIT:
        case SWIFI_TEST_TEXT:
        case SWIFI_TEST_BRANCH:
        case SWIFI_TEST_INVERSE:
        case SWIFI_TEST_PTR:
        case SWIFI_TEST_DSTSRC:
        case SWIFI_TEST_INTERFACE:
        case SWIFI_TEST_INIT:
            return 1;
    }
    return 0;
}

static int is_data_fault(int cmd)
{
    switch(cmd) {
        case SWIFI_STACK:
        case SWIFI_HEAP:
        case SWIFI_DATA:
        case SWIFI_BSS:
        case SWIFI_TEST_STACK:
        case SWIFI_TEST_HEAP:
        case SWIFI_TEST_DATA:
        case SWIFI_TEST_BSS:
            return 1;
    }
    return 0;
}

struct swifi_op {
    int cmd;
    u128 (*inject_fault)(unsigned long, size_t);
    unsigned long (*get_target)(void);
    void (*result_report)(struct swifi_result *);
};

static struct swifi_op sop[] = {
    {SWIFI_TEXT, flip_random_bit, get_random_text_addr, result_text},
    {SWIFI_STACK, flip_random_bit, get_random_stack_addr, result_stack},
    {SWIFI_HEAP, flip_random_bit, get_random_heap_addr, result_other},
    {SWIFI_DATA, flip_random_bit, get_random_data_addr, result_other},
    {SWIFI_BSS, flip_random_bit, get_random_bss_addr, result_other},
    {SWIFI_BRANCH, fill_nop, get_branch_instr, result_text},
    {SWIFI_INVERSE, inverse_branch, get_branch_instr, result_text},
    {SWIFI_PTR, flip_ptr, get_ptr_instr, result_text},
    {SWIFI_DSTSRC, flip_dstsrc, get_dstsrc_instr, result_text},
    {SWIFI_INTERFACE, fill_nop, get_interface_instr, result_text},
    {SWIFI_INIT, fill_nop, get_init_instr, result_text},

    {SWIFI_TEST_TEXT, test_flip_random_bit, get_random_text_addr, result_text},
    {SWIFI_TEST_STACK, test_flip_random_bit, get_random_stack_addr, result_stack},
    {SWIFI_TEST_HEAP, test_flip_random_bit, get_random_heap_addr, result_other},
    {SWIFI_TEST_DATA, test_flip_random_bit, get_random_data_addr, result_other},
    {SWIFI_TEST_BSS, test_flip_random_bit, get_random_bss_addr, result_other},
    {SWIFI_TEST_BRANCH, test_fill_nop, get_branch_instr, result_text},
    {SWIFI_TEST_INVERSE, test_inverse_branch, get_branch_instr, result_text},
    {SWIFI_TEST_PTR, test_flip_ptr, get_ptr_instr, result_text},
    {SWIFI_TEST_DSTSRC, test_flip_dstsrc, get_dstsrc_instr, result_text},
    {SWIFI_TEST_INTERFACE, test_fill_nop, get_interface_instr, result_text},
    {SWIFI_TEST_INIT, test_fill_nop, get_init_instr, result_text},
    {SWIFI_OFFBYONE, offbyone, get_offbyone_instr, result_text},
    {SWIFI_TEST_OFFBYONE, test_offbyone, get_offbyone_instr, result_text},
/* add new swifi_op from this line */
    {SWIFI_DONOTHING, do_nothing, get_null, result_nothing}
};

long do_swifi(int cmd, unsigned long seed, struct swifi_result __user * result)
{
    int ret = -1;
	size_t byte;
    struct swifi_op * op;
	struct swifi_result * res = kzalloc(sizeof(struct swifi_result), GFP_KERNEL);
	
    if (!res)
        return -1;

	srand(seed);

    op = &sop[(cmd < SWIFI_DONOTHING)?cmd:SWIFI_DONOTHING];
	res->target = op->get_target();
    if (probe_kernel_read(&res->old_content, (u128 *)res->target, sizeof(u128)))
        goto final;

    if (is_text_fault(op->cmd) && __kernel_text_address(res->target)) {
        byte = do_disasm((unsigned long)&res->old_content, NULL, 0);
        if (byte > sizeof(u128))
            goto final;
    } else if (is_data_fault(op->cmd)){
		byte = sizeof(u128);
    } else
        goto final;
    
    res->new_content = op->inject_fault(res->target, byte);
    op->result_report(res);
    ret = copy_to_user(result, res, sizeof(struct swifi_result));
final:
    kfree(res);
	return ret;

}

SYSCALL_DEFINE3(swifi, int, cmd, unsigned long, seed, struct swifi_result __user *, result)
{
    tstart = (unsigned long)_stext;
    tend   = (unsigned long)_etext;
    return do_swifi(cmd, seed, result);
}

SYSCALL_DEFINE1(direct_swifi, struct swifi_result __user *, s)
{
    int ret = -1;
	struct swifi_result * res = kzalloc(sizeof(struct swifi_result), GFP_KERNEL);
    
    if (!res)
        return -1;
    if (copy_from_user(res, s, sizeof(struct swifi_result))) 
        goto final;
    if (probe_kernel_read(&res->old_content, (u128 *)res->target, sizeof(u128 *))) 
        goto final;
    force_to_write((u128 *)res->target, &res->new_content);
    ret = copy_to_user(s, res, sizeof(struct swifi_result));
final:
    kfree(res);
    return ret;
}

SYSCALL_DEFINE4(mod_swifi, const char *, name, int, cmd, unsigned long, seed, struct swifi_result __user *, result)
{
    unsigned long start, end;
    char str[256];
    struct module * mod;

    copy_from_user(str, name, 256);
    mod = find_module(str);
    if (!mod)
        return -1;
    start = (unsigned long)mod->module_core;
    end   = (unsigned long)mod->module_core + mod->core_text_size;
    tstart = start;
    tend   = end;
    return do_swifi(cmd, seed, result);
}

